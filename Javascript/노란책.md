# 자바스크립트 노란책 공부  
## 4. 변수와 스코프, 메모리  
### 변수  
  자바스크립트의 변수는 다른 언어에 비해 독특하다.  
  자바스크립트 변수는 느슨한 타입을 취하므로 변수는 특정 시간에서 특정 값을 가리키는, 문자 그대로 이름일 뿐이다.  
  자바스크립트 변수는 그 값을 원시 값과 참조 값 2가지로 분류할 수 있다.  
  - 원시 값은 단순한 데이터로 변수에 저장된 실제 값을 다룬다. 그에 비해 참조 값은 메모리에 저장된 객체로 메모리 위치에 직접 접근하는 것을 허용하지 않는 자바스크립트의 특성 상 객체에 대한 '참조'를 다룬다.  
  - 동적 프로퍼티  
    원시 값과 달리 참조 값은 언제든지 프로퍼티와 메서드를 추가하여 사용할 수 있다.  
    - 참조 값 프로퍼티 추가  
    ```js  
      var person = new Object();  
      person.name = "foresthb";  
      console.log(person.name); // "foresthb"  
    ```  
    - 원시 값 프로퍼티 추가  
    ```js  
      var name = "foresthb";  
      name.age = 25;  
      console.log(name.age); // undefined  
    ```  
    원시 값에는 프로퍼티가 없으므로 사용할 수는 없으나 추가하려 해도 에러는 발생하지 않는다.  


  - 값 복사  
    값을 복사할 경우, 원시 값은 현재 저장된 값을 새로 생성한 후 다른 변수에 저장한다.  
    그에 비해, 참조 값은 저장된 값이 아닌 메모리에 저장된 값을 가리키는 포인터를 복사하여 다른 변수에 저장한다.  
  - 매개변수 전달  
    ```js  
      function addOne(num) {
        num += 1;
        return num;
      }

      var wood = 99;
      addOne(wood); // 99. wood 변동 없음
      console.log(wood); // 100
    ```  
    원시 값을 매개변수로 전달할 경우, addOne 메서드 내부에 wood의 값을 복사하여 num이라는 지역변수에 저장한다.  
    그 후 1을 더한 후 그 값을 반환한다.  
    실제로 1이 더해진 변수는 메서드 외부의 wood가 아니라 메서드 내부의 num 지역변수이기 때문에 메서드를 실행해도 wood의 값은 변하지 않는다.  

    ```js  
      function newName(obj) {
        obj.name = "foresthb";
        obj = new Object();
        obj.name = "mountainhb";
      }

      var person = new Object();
      newName(person); // person의 name 프로퍼티 변동
      console.log(person.name); // foresthb
    ```  
    참조 값이 매개변수로 전달할 경우, 해당 객체를 복사하여 newName 메서드의 변수 obj에 저장한다.  
    위의 값 복사와 달리, 참조가 아닌 값의 형태로 메서드에 전달되었지만 참조를 통해 객체에 접근하며,  
    메서드 내부의 obj 객체와 외부의 person 객체는 메모리의 같은 값을 가리키므로 메서드 내부에서 프로퍼티를 변경할 경우, 외부에서도 변경된다.  
    그리고, 메서드 내부에서 매개변수로 전달받은 obj 객체를 새로운 객체로 재정의 하더라도 원래 객체에 대한 참조를 그대로 유지한다.

### 실행 컨텍스트와 스코프  
  실행 컨텍스트(execution context) 혹은 컨텍스트는 자바스크립트에서 매우 중요한 개념이다.  
  변수나 함수의 컨텍스트는 다른 데이터에 접근할 수 있는지, 어떻게 행동하는 지를 규정한다.  
  컨텍스트에서 코드를 실행할 경우 변수 객체에 스코프 체인이 만들어진다. 스코프 체인의 목적은 실행 컨텍스트가 접근할 수 있는 모든 변수와 함수 순서를 정의하는 것이다.  다시 말하면, 스코프 체인은 변수 등의 식별자(Identifiers)를 찾는 과정이라고 할 수 있다.  
  컨텍스트가 함수라면 활성화 객체(activation object)를 변수 객체로 사용한다. 활성화 객체는 항상 argument 변수 단 하나로 시작한다. 식별자를 찾을 때는 스코프 체인 순서를 따라가면서 해당 식별자 이름을 검색한다.  
  ```js  
    let desert = "cake";
    function changeOrder() {
      if(desert == "cake") {
        desert = "coffee";
      } else {
        desert = "cake";
      }
    }

    changeOrder();
  ```  
  위 코드에서 함수 changeOrder의 스코프 체인에는 객체가 두 개 들어 있다. 하나는 함수 자체의 변수 객체이며, 또 다른 하나는 전역 컨텍스트의 변수 객체이다. 변수 desert는 함수의 스코프 체인에서 찾을 수 있으므로 접근 가능하다.  

  ```js  
    let desert = "cake";
    function changeOrder() {
      let anotherDesert = "coffee";

      function swapOrder() {
        let temp = anotherDesert;
        anotherDesert = desert;
        desert = temp;
        // 모든 변수 접근 가능
      }
      // desert, anotherDesert 접근 가능
      swapOrder();
    }
    // desert만 접근 가능
    changeOrder();
  ```  
  위 코드에서는 실행 컨텍스트가 3개가 있다. 전역 컨텍스트, changeOrder 함수의 로컬 컨텍스트, swapOrder의 로컬 컨텍스트이다.  
  내부 컨텍스트는 스코프 체인을 통해 외부 컨텍스트에 접근할 수 있지만, 외부 컨텍스트는 내부 컨텍스트에 접근할 수 없다. 컨텍스트 사이의 연결은 선행이며, 순서가 중요하다. 각 컨텍스트는 스코프 체인을 따라 상위 컨텍스트에서 변수나 함수를 검색할 수는 있지만, 스코프 체인을 따라 내려가며 검색하는 것은 불가능하다.  

  - 스코프 체인 확장  
    코드 실행이 끝나면 사라지는 변수 객체를 임시로 만들 수 있는 경우가 다음과 같이 2가지 있다.  
      - try-catch 문의 catch문  
      - with 문  

    두 문장은 모두 스코프 체인 앞에 변수 객체를 추가한다. with문에서는 해당 객체가 스코프 체인에 추가되며, catch 문에서는 에러 객체를 선언하는 변수 객체가 생성된다.  

  - 함수 레벨 스코프 & 블록 레벨 스코프  
    대부분의 프로그래밍 언어는 블록 레벨 스코프를 지원하지만, 자바스크립트는 함수 레벨 스코프를 갖는다.  
      - 함수 레벨 스코프 : 함수 내에서 선언된 변수는 함수 내에서만 유효하며 함수 외부에서는 참조할 수 없다. 즉 함수 내부에서 선언한 변수는 지역 변수이며 함수 외부에서 선언한 변수는 모두 전역 변수이다.  
      - 블록 레벨 스코프 : 코드 블록 내에서 선언된 변수는 코드 블록 내에서만 유효하며 코드 블록 외부에서는 참조할 수 없다.  

    ES5에서 변수를 선언할 수 있는 유일한 방법은 var 키워드를 사용하는 것이었다. var 키워드로 선언된 변수는 아래와 같은 특징이 있다.  
      - 함수 레벨 스코프  
      - 중복 선언 허용  
      - 키워드 생략 허용  
      - [변수 호이스팅][https://poiemaweb.com/js-data-type-variable#24-%EB%B3%80%EC%88%98-%ED%98%B8%EC%9D%B4%EC%8A%A4%ED%8C%85variable-hoisting]  

    이러한 특성들로 인해 var 키워드로 전역화가 일어나게 되어 넓은 유효범위로 인해 어디서 어떻게 사용될 것인지 파악하기가 힘들고 코드의 복잡성을 증가시키는 원인이 되었다.  
    ES6에서는 이러한 문제를 보완하기 위해 let과 const 키워드를 도입하게 된다.  
      - let, const는 블록 레벨 스코프를 갖는다. 또한 var과 다르게 중복 선언을 허용하지 않고, 호이스팅 자체를 지원하기는 하지만 선언문 이전에 참조할 경우 참조 에러가 발생한다.  
      - let의 경우에는 중복 선언을 허용하지 않지만 선언문 이후에 그 값 자체를 변화시킬 수는 있는 반면에, const는 값을 변화시키는 것 또한 허용하지 않는다.  
