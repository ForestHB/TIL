# 자바스크립트 노란책 공부  
## 4. 변수와 스코프, 메모리  
### 변수  
  자바스크립트의 변수는 다른 언어에 비해 독특하다.  
  자바스크립트 변수는 느슨한 타입을 취하므로 변수는 특정 시간에서 특정 값을 가리키는, 문자 그대로 이름일 뿐이다.  
  자바스크립트 변수는 그 값을 원시 값과 참조 값 2가지로 분류할 수 있다.  
  - 원시 값은 단순한 데이터로 변수에 저장된 실제 값을 다룬다. 그에 비해 참조 값은 메모리에 저장된 객체로 메모리 위치에 직접 접근하는 것을 허용하지 않는 자바스크립트의 특성 상 객체에 대한 '참조'를 다룬다.  
  - 동적 프로퍼티  
    원시 값과 달리 참조 값은 언제든지 프로퍼티와 메서드를 추가하여 사용할 수 있다.  
    - 참조 값 프로퍼티 추가  
    ```js  
      var person = new Object();  
      person.name = "foresthb";  
      console.log(person.name); // "foresthb"  
    ```  
    - 원시 값 프로퍼티 추가  
    ```js  
      var name = "foresthb";  
      name.age = 25;  
      console.log(name.age); // undefined  
    ```  
    원시 값에는 프로퍼티가 없으므로 사용할 수는 없으나 추가하려 해도 에러는 발생하지 않는다.  


  - 값 복사  
    값을 복사할 경우, 원시 값은 현재 저장된 값을 새로 생성한 후 다른 변수에 저장한다.  
    그에 비해, 참조 값은 저장된 값이 아닌 메모리에 저장된 값을 가리키는 포인터를 복사하여 다른 변수에 저장한다.  
  - 매개변수 전달  
    ```js  
      function addOne(num) {
        num += 1;
        return num;
      }

      var wood = 99;
      addOne(wood); // 99. wood 변동 없음
      console.log(wood); // 100
    ```  
    원시 값을 매개변수로 전달할 경우, addOne 메서드 내부에 wood의 값을 복사하여 num이라는 지역변수에 저장한다.  
    그 후 1을 더한 후 그 값을 반환한다.  
    실제로 1이 더해진 변수는 메서드 외부의 wood가 아니라 메서드 내부의 num 지역변수이기 때문에 메서드를 실행해도 wood의 값은 변하지 않는다.  

    ```js  
      function newName(obj) {
        obj.name = "foresthb";
        obj = new Object();
        obj.name = "mountainhb";
      }

      var person = new Object();
      newName(person); // person의 name 프로퍼티 변동
      console.log(person.name); // foresthb
    ```  
    참조 값이 매개변수로 전달할 경우, 해당 객체를 복사하여 newName 메서드의 변수 obj에 저장한다.  
    위의 값 복사와 달리, 참조가 아닌 값의 형태로 메서드에 전달되었지만 참조를 통해 객체에 접근하며,  
    메서드 내부의 obj 객체와 외부의 person 객체는 메모리의 같은 값을 가리키므로 메서드 내부에서 프로퍼티를 변경할 경우, 외부에서도 변경된다.  
    그리고, 메서드 내부에서 매개변수로 전달받은 obj 객체를 새로운 객체로 재정의 하더라도 원래 객체에 대한 참조를 그대로 유지한다.

### 실행 컨텍스트와 스코프  
  실행 컨텍스트(execution context) 혹은 컨텍스트는 자바스크립트에서 매우 중요한 개념이다.  
  변수나 함수의 컨텍스트는 다른 데이터에 접근할 수 있는지, 어떻게 행동하는 지를 규정한다.  
  컨텍스트에서 코드를 실행할 경우 변수 객체에 스코프 체인이 만들어진다. 스코프 체인의 목적은 실행 컨텍스트가 접근할 수 있는 모든 변수와 함수 순서를 정의하는 것이다.  다시 말하면, 스코프 체인은 변수 등의 식별자(Identifiers)를 찾는 과정이라고 할 수 있다.  
  컨텍스트가 함수라면 활성화 객체(activation object)를 변수 객체로 사용한다. 활성화 객체는 항상 argument 변수 단 하나로 시작한다. 식별자를 찾을 때는 스코프 체인 순서를 따라가면서 해당 식별자 이름을 검색한다.  
  ```js  
    let desert = "cake";
    function changeOrder() {
      if(desert == "cake") {
        desert = "coffee";
      } else {
        desert = "cake";
      }
    }

    changeOrder();
  ```  
  위 코드에서 함수 changeOrder의 스코프 체인에는 객체가 두 개 들어 있다. 하나는 함수 자체의 변수 객체이며, 또 다른 하나는 전역 컨텍스트의 변수 객체이다. 변수 desert는 함수의 스코프 체인에서 찾을 수 있으므로 접근 가능하다.  

  ```js  
    let desert = "cake";
    function changeOrder() {
      let anotherDesert = "coffee";

      function swapOrder() {
        let temp = anotherDesert;
        anotherDesert = desert;
        desert = temp;
        // 모든 변수 접근 가능
      }
      // desert, anotherDesert 접근 가능
      swapOrder();
    }
    // desert만 접근 가능
    changeOrder();
  ```  
  위 코드에서는 실행 컨텍스트가 3개가 있다. 전역 컨텍스트, changeOrder 함수의 로컬 컨텍스트, swapOrder의 로컬 컨텍스트이다.  
  내부 컨텍스트는 스코프 체인을 통해 외부 컨텍스트에 접근할 수 있지만, 외부 컨텍스트는 내부 컨텍스트에 접근할 수 없다. 컨텍스트 사이의 연결은 선행이며, 순서가 중요하다. 각 컨텍스트는 스코프 체인을 따라 상위 컨텍스트에서 변수나 함수를 검색할 수는 있지만, 스코프 체인을 따라 내려가며 검색하는 것은 불가능하다.  

  - 스코프 체인 확장  
    코드 실행이 끝나면 사라지는 변수 객체를 임시로 만들 수 있는 경우가 다음과 같이 2가지 있다.  
      - try-catch 문의 catch문  
      - with 문  

    두 문장은 모두 스코프 체인 앞에 변수 객체를 추가한다. with문에서는 해당 객체가 스코프 체인에 추가되며, catch 문에서는 에러 객체를 선언하는 변수 객체가 생성된다.  

  - 함수 레벨 스코프 & 블록 레벨 스코프  
    대부분의 프로그래밍 언어는 블록 레벨 스코프를 지원하지만, 자바스크립트는 함수 레벨 스코프를 갖는다.  
      - 함수 레벨 스코프 : 함수 내에서 선언된 변수는 함수 내에서만 유효하며 함수 외부에서는 참조할 수 없다. 즉 함수 내부에서 선언한 변수는 지역 변수이며 함수 외부에서 선언한 변수는 모두 전역 변수이다.  
      - 블록 레벨 스코프 : 코드 블록 내에서 선언된 변수는 코드 블록 내에서만 유효하며 코드 블록 외부에서는 참조할 수 없다.  

    ES5에서 변수를 선언할 수 있는 유일한 방법은 var 키워드를 사용하는 것이었다. var 키워드로 선언된 변수는 아래와 같은 특징이 있다.  
      - 함수 레벨 스코프  
      - 중복 선언 허용  
      - 키워드 생략 허용  
      - [변수 호이스팅](https://poiemaweb.com/js-data-type-variable#24-%EB%B3%80%EC%88%98-%ED%98%B8%EC%9D%B4%EC%8A%A4%ED%8C%85variable-hoisting)  

    이러한 특성들로 인해 var 키워드로 전역화가 일어나게 되어 넓은 유효범위로 인해 어디서 어떻게 사용될 것인지 파악하기가 힘들고 코드의 복잡성을 증가시키는 원인이 되었다.  
    ES6에서는 이러한 문제를 보완하기 위해 let과 const 키워드를 도입하게 된다.  
      - let, const는 블록 레벨 스코프를 갖는다. 또한 var과 다르게 중복 선언을 허용하지 않고, 호이스팅 자체를 지원하기는 하지만 선언문 이전에 참조할 경우 참조 에러가 발생한다.  
      - let의 경우에는 중복 선언을 허용하지 않지만 선언문 이후에 그 값 자체를 변화시킬 수는 있는 반면에, const는 값을 변화시키는 것 또한 허용하지 않는다.  

### 가비지 컬렉션  
  가비지 컬렉션이란 동적 할당된 메모리 영역 가운데 더 이상 사용하지 않게 된 영역을 탐지하여 해제하는 기법이다.  
  자바스크립트는 C 계열 언어들과 달리 자동으로 가비지 컬렉션이 가능하므로 가비지 컬렉션 언어라고도 불린다. 하지만 사실 '자동'이라는 단어에는 혼란의 여지가 있다. 이는 자바스크립트를 포함한 여러 고급 언어 개발자들에게 메모리 관리가 불가능하다는 인상을 준다. 하지만 실상은 그렇지 않다.  
  - 더 이상 필요없는 메모리  
    일반적으로 '더 이상' 필요없는 '모든' 메모리를 찾는 것은 알고리즘으로는 풀 수 없는 비결정적인 문제이다. 가비지 컬렉터는 안전하지만 완전하지는 않다. 항상 필요없어진 메모리를 해제하지만 모든 필요없어진 메모리를 해제하는 것은 아니다.  
    - 참조 세기(Reference-counting)  
      참조 세기란 '더 이상 필요없는' 오브젝트를 '아무런 오브젝트도 참조하지 않는' 오브젝트로 정의한 것이다. 어떤 오브젝트를 참조하는 다른 오브젝트가 하나도 존재하지 않을 경우, 가비지 컬렉션을 수행한다. 이 알고리즘은 가장 무난한 알고리즘이지만, 두 오브젝트가 서로를 참조할 경우 문제가 발생한다.  
      두 옵젝트가 서로를 참조하여 순환이 일어나면, 두 오브젝트가 함수 컨텍스트 내부에서 메모리가 할당되어 컨텍스트가 끝난 후 실질적으로 더 이상 오브젝트가 필요없어져도 참조가 되고 있기 때문에 가비지 컬렉션을 수행하지 않는다. 결국 사용하지 않는 메모리가 해제되지 않으므로 메모리 누수가 발생한다.  
    - 표시하고 제거하기(Mark-and-sweep)  
      표시하고 제거하기는 '더 이상 필요없는' 오브젝트를 '닿을 수 없는' 오브젝트로 정의한다.  
      변수가 한 컨텍스트 안에서 정의되면, 그 변수는 컨텍스트 내부에 있는 경우 컨텍스트가 '닿을 수 있는' 변수로 간주한다. 그 후 컨텍스트가 컨텍스트 밖으로 나가면 그 컨텍스트가 '닿을 수 없는' 변수로 간주한다. 즉, 하나의 컨텍스트 내부에서 정의된 변수는 그 컨텍스트에서만 필요한 변수라고 정의하여 컨텍스트 외부로 이동할 경우 필요없는 오브젝트로 간주하여 가비지 컬렉션을 수행하는 것이다.  
      전역 컨텍스트에서 정의된 변수에 대해서는, 이 알고리즘에서는 roots라는 오브젝트의 집합을 가지고 있는데 자바스크립트에서는 전역 변수를 의미한다. 전역 컨텍스트에서 정의된 변수는 roots를 벗어나게 되면 필요없는 오브젝트로 간주되어 해제된다.  
      위의 참조 세기에서 언급한 순환 참조의 경우도 이 알고리즘에서는 문제가 되지 않는다. 서로를 참조하는 두 오브젝트 또한, 정의된 컨텍스트를 벗어날 경우 가비지 컬렉션이 수행된다.

## 5. 참조 타입  
  ECMAscript에서 참조 타입은 데이터와 기능을 그룹으로 묶는 구조이고, 참조 값이란 특정 '참조 타입'의 인스턴트이다.  
  흔히 참조 타입을 '클래스'라고도 하는데 이는 잘못된 표현이다.  
### Object 타입  
  Object 타입은 참조 타입, 값 예제에서 가장 많이 쓰이는 타입이며, ECMAscript에서 가장 많이 사용되는 타입이기도 하다.  
  많은 기능이 들어있지는 않지만 애플리케이션에 사용할 데이터를 저장하고 전송하는 목적에는 안성맞춤이다.  
  - 인스턴스의 명시적 생성  
    방법은 크게 2가지다.  
    첫번째는 new 키워드를 사용하여 생성자와 함께 쓰는 것이고, 다른 하나는 객체 리터럴 표기법이다.  
    ```js  
      let person = new Object();
      person.name = "foresthb";
      person.age = 25;
    ```  
    ```js  
      let person = {
        name: "foresthb",
        age: 25
      }
    ```  
    두번째 코드가 바로 객체 리터럴 표기법인데, 여기서 왼쪽 중괄호는 객체 리터럴의 시작을 나타낸다. 왼쪽 중괄호는 여러가지 목적으로 사용될 수 있음에도 이 코드에서 객체 리터럴의 시작임을 분명히 알 수 있는 이유는 '표현식 컨텍스트'에 있기 때문이다.  
    ECMAscript에서 표현식 컨텍스트란 값(표현식)이 예상되는 컨텍스트를 의미한다.  
    중괄호 내부는 프로퍼티. 콜론, 프로퍼티의 값 순서대로 오며, 프로퍼티들은 쉼표로 구분한다. 객체 리터럴 표기법에서는 프로퍼티 명에 문자열이나 숫자를 사용할 수 있지만 숫자는 자동으로 문자열로 바뀐다.  
    ```js  
      let person = {
        "name" : "foresthb";
        "age" : 25,
        5 : true // "5" : true
      }
    ```  
    객체 리터럴 표기법을 사용할 때 중괄호 안을 빈공간으로 남겨두면, 생성자를 사용할 때와 마찬가지로 기본 프로퍼티와 메서드만을 가진 객체를 만들 수 있다.  
    ```js  
    let person = {};
    person.name = "foresthb";
    person.age = 25;
    ```  

    프로퍼티에 접근할 경우에도 2가지 표기법이 있는데, 점 표기법과 대괄호 표기법이다.  
    점 표기법은 위의 코드들 처럼 "."을 사용하는 것이고, 대괄호 표기법은 대괄호 "[]"를 사용하는 것이다.  
    ```js  
      console.log(person.name); // "foresthb"
      console.log(person["name"]); // "foresthb"
    ```  

    대괄호 표기법을 사용하면, 점 표기법을 사용할 경우에는 오류가 발생하는 이름을 가진 프로퍼티에도 접근할 수 있다.  
    ```js  
      let person = {
        "first name" : "John"
      }

      console.log(person["first name"]);
    ```  
    "first name" 프로퍼티는 이름에 공백이 들어가기 때문에 점 표기법으로는 접근할 수 없다.
